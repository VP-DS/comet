// This file has been generated by comet api-generator.
// You may choose to use this file as scaffold by moving this file out of generated folder and removing this comment.
import { extractGraphqlFields, SubjectEntity } from "@comet/cms-api";
import { FindOptions, Reference } from "@mikro-orm/core";
import { InjectRepository } from "@mikro-orm/nestjs";
import { EntityManager, EntityRepository } from "@mikro-orm/postgresql";
import { Args, ID, Info, Mutation, Parent, Query, ResolveField, Resolver } from "@nestjs/graphql";
import { GraphQLResolveInfo } from "graphql";

import { ContentScopeOnEntiy, MyScopeEntity } from "../entities/my-scope.entity";
import { MyTestEntityUsingScope } from "../entities/my-test-using-scope.entity";
import { MyTestEntityUsingScopeInput, MyTestEntityUsingScopeUpdateInput } from "./dto/my-test-entity-using-scope.input";
import { MyTestEntityUsingScopesArgs } from "./dto/my-test-entity-using-scopes.args";
import { PaginatedMyTestEntityUsingScopes } from "./dto/paginated-my-test-entity-using-scopes";
import { MyTestEntityUsingScopesService } from "./my-test-entity-using-scopes.service";

@Resolver(() => MyTestEntityUsingScope)
export class MyTestEntityUsingScopeResolver {
    constructor(
        private readonly entityManager: EntityManager,
        private readonly myTestEntityUsingScopesService: MyTestEntityUsingScopesService,
        @InjectRepository(MyTestEntityUsingScope) private readonly repository: EntityRepository<MyTestEntityUsingScope>,
        @InjectRepository(MyScopeEntity) private readonly myScopeEntityRepository: EntityRepository<MyScopeEntity>,
    ) {}

    @Query(() => MyTestEntityUsingScope)
    @SubjectEntity(MyTestEntityUsingScope)
    async myTestEntityUsingScope(@Args("id", { type: () => ID }) id: string): Promise<MyTestEntityUsingScope> {
        const myTestEntityUsingScope = await this.repository.findOneOrFail(id);
        return myTestEntityUsingScope;
    }

    @Query(() => PaginatedMyTestEntityUsingScopes)
    async myTestEntityUsingScopes(
        @Args() { scope, offset, limit }: MyTestEntityUsingScopesArgs,
        @Info() info: GraphQLResolveInfo,
    ): Promise<PaginatedMyTestEntityUsingScopes> {
        const where = {};
        where.scope = scope;

        const fields = extractGraphqlFields(info, { root: "nodes" });
        const populate: string[] = [];
        if (fields.includes("scope_scopeEntity")) {
            populate.push("scope_scopeEntity");
        }

        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const options: FindOptions<MyTestEntityUsingScope, any> = { offset, limit, populate };

        const [entities, totalCount] = await this.repository.findAndCount(where, options);
        return new PaginatedMyTestEntityUsingScopes(entities, totalCount);
    }

    @Mutation(() => MyTestEntityUsingScope)
    async createMyTestEntityUsingScope(
        @Args("scope", { type: () => ContentScopeOnEntiy }) scope: ContentScopeOnEntiy,
        @Args("input", { type: () => MyTestEntityUsingScopeInput }) input: MyTestEntityUsingScopeInput,
    ): Promise<MyTestEntityUsingScope> {
        const { scope_scopeEntity: scope_scopeEntityInput, ...assignInput } = input;
        const myTestEntityUsingScope = this.repository.create({
            ...assignInput,

            scope,
            scope_scopeEntity: Reference.create(await this.myScopeEntityRepository.findOneOrFail(scope_scopeEntityInput)),
        });

        await this.entityManager.flush();

        return myTestEntityUsingScope;
    }

    @Mutation(() => MyTestEntityUsingScope)
    @SubjectEntity(MyTestEntityUsingScope)
    async updateMyTestEntityUsingScope(
        @Args("id", { type: () => ID }) id: string,
        @Args("input", { type: () => MyTestEntityUsingScopeUpdateInput }) input: MyTestEntityUsingScopeUpdateInput,
    ): Promise<MyTestEntityUsingScope> {
        const myTestEntityUsingScope = await this.repository.findOneOrFail(id);

        const { scope_scopeEntity: scope_scopeEntityInput, ...assignInput } = input;
        myTestEntityUsingScope.assign({
            ...assignInput,

            scope_scopeEntity: Reference.create(await this.myScopeEntityRepository.findOneOrFail(scope_scopeEntityInput)),
        });

        await this.entityManager.flush();

        return myTestEntityUsingScope;
    }

    @Mutation(() => Boolean)
    @SubjectEntity(MyTestEntityUsingScope)
    async deleteMyTestEntityUsingScope(@Args("id", { type: () => ID }) id: string): Promise<boolean> {
        const myTestEntityUsingScope = await this.repository.findOneOrFail(id);
        await this.entityManager.remove(myTestEntityUsingScope);
        await this.entityManager.flush();
        return true;
    }

    @ResolveField(() => MyScopeEntity)
    async scope_scopeEntity(@Parent() myTestEntityUsingScope: MyTestEntityUsingScope): Promise<MyScopeEntity> {
        return myTestEntityUsingScope.scope_scopeEntity.load();
    }
}
