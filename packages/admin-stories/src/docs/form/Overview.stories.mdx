import { Meta, Story, Canvas, Source } from "@storybook/addon-docs";

import dedent from "ts-dedent";

<Meta title="Docs/Form/Overview" />

# Form Overview

Forms enable users to submit information to a web application. Therefore, forms belong to the essential features of every admin application.

In Comet Admin, React Final Form (RFF) is used for building forms. You can find more information on this framework in the [React Final Form Docs](https://final-form.org/docs/react-final-form/getting-started).

## When (not) to use Final Form

Final Form is strongly recommended if you

-   are building an extensive or complicated form
-   want to submit the form data to an API

However, Final Form might not be sensible for every use case.
Final Form is likely overkill if you want to create a solitary input field (e.g., a single select field for client-side filtering).
In this case, you can use a plain input component combined with a React state.

## `FinalForm` Component

Comet Admin provides a `FinalForm` component.
It's built on top of React Final Form's [`Form` component](https://final-form.org/docs/react-final-form/api/Form).

There are two required properties:

-   `mode` can be `add` (for creating a new resource) or `edit` (for editing an existing resource)
-   `onSubmit()` handles the submission of form values to the API

<Canvas>
    <Story id="stories-form-finalform--basic-finalform" />
</Canvas>

### Submit Mutation Best Practices

We recommend abiding by the following best practices considering form submission mutations:

#### Location of GraphQL Mutations

You should define form-related mutations in an adjacent file of the same name with the suffix `.gql.ts`.
For example, if your form is located in the file `employees/EmployeeForm.tsx`, the mutation should be defined in `employees/EmployeeForm.gql.ts`.

<Source
    language="tsx"
    code={dedent`
        // employees/EmployeeForm.tsx
        <FinalForm
            mode="add"
            onSubmit={(values) => {
                // ...
            }}
        >
            <Field label="Name" name="name" component={FinalFormInput} />
            <SaveButton type="submit" />
        </FinalForm>
  `}
/>

<Source
    language="ts"
    code={dedent`
        // employees/EmployeeForm.gql.ts
        export const createEmployeeMutation = gql\`
            mutation CreateEmployee($input: CreateEmployeeInput!) {
                createEmployee(input: $input) {
                    id
                    name
                }
            }
        \`;
  `}
/>

If the form is short and simple, you can also define the mutation at the top of the same file.

<Source
    language="tsx"
    code={dedent`
        // employees/EmployeeForm.tsx
        const createEmployeeMutation = gql\`
            mutation CreateEmployee($input: CreateEmployeeInput!) {
                createEmployee(input: $input) {
                    id
                    name
                }
            }
        \`;
        // ...
        <FinalForm
            mode="add"
            onSubmit={(values) => {
                // ...
            }}
        >
            <Field label="Name" name="name" component={FinalFormInput} />
            <SaveButton type="submit" />
        </FinalForm>
`}
/>

#### `apolloClient.mutate()` vs `useMutation()` Hook

Prefer `apolloClient.mutate()` over the `useMutation()` hook to prevent the introduction of unnecessary new variables.
Thereby, you avoid a difficult variable naming process, and your code stays short and precise.

**✅ Do this:**

<Source
    language="tsx"
    code={dedent`
        const apolloClient = useApolloClient();
        // ...
        <FinalForm
            mode="add"
            onSubmit={async (values) => {
                await apolloClient.mutate({
                    mutation: createEmployeeMutation,
                    variables: {
                        input: {
                            name: values.name
                        }
                    }
                })
            }}
        >
            <Field label="Name" name="name" component={FinalFormInput} />
            <SaveButton type="submit" />
        </FinalForm>
`}
/>

**❌ Avoid this:**

<Source
    language="tsx"
    code={dedent`
        // you need to bother with naming this variable
        const const [createEmployee] = useMutation(createEmployeeMutation);
        // ...
        <FinalForm
            mode="add"
            onSubmit={async (values) => {
                // you don't see at first glance, that this is a call to a GraphQL API
                await createEmployee({
                    variables: {
                        input: {
                            name: values.name
                        }
                    }
                })
            }}
        >
            <Field label="Name" name="name" component={FinalFormInput} />
            <SaveButton type="submit" />
        </FinalForm>
`}
/>

#### Mutation Variables

A mutation should have an `input` variable that bundles all changeable attributes.
Attributes that can't be changed should be solitary variables (e.g., `id` or other variables used for identifying a specific resource).

<Source
    language="tsx"
    code={dedent`
        const updateEmployeeMutation = gql\`
            mutation UpdateEmployee($id: ID!, $input: UpdateEmployeeInput!) {
                updateEmployee(id: $id, input: $input) {
                    id
                    firstname
                    lastname
                }
            }
        \`;
        // ...
        const apolloClient = useApolloClient();
        // ...
        <FinalForm
            mode="add"
            onSubmit={async (values) => {
                await apolloClient.mutate({
                    mutation: updateEmployeeMutation,
                    variables: {
                        id: employeeId,
                        input: {
                            firstname: values.firstname,
                            lastname: values.lastname
                        }
                    }
                })
            }}
        >
            <Field label="Firstname" name="firstname" component={FinalFormInput} />
            <Field label="Lastname" name="lastname" component={FinalFormInput} />
            <SaveButton type="submit" />
        </FinalForm>
`}
/>

#### Form Submission Example

**Note:** You have to enter "John" and "Doe" for this example to work.

<Canvas>
    <Story id="stories-form-finalform--submit-mutation-best-practices" />
</Canvas>

### Context-based Features

Comet Admin `FinalForm` uses React Contexts to interact with other Comet Admin components.

#### FinalForm in a Table

If your `FinalForm` is located inside a [TableQuery](/story/docs-components-table-tablequery--page) component, the tableQuery is refetched automatically after submission.

#### FinalForm in a Stack

If a `FinalForm` is used inside a [Stack](/story/docs-components-stack--page), it automatically navigates back to the previous `StackPage`.

<Canvas>
    <Story id="stories-form-context-based-features--finalform-in-stack" />
</Canvas>

This is not always desired.
For example, if the FinalForm isn't located on an own StackPage.
In this case you have to override the `onAfterSubmit()` function of `FinalForm`.

<Source
    language="tsx"
    code={dedent`
    <FinalForm
        // ...
        onAfterSubmit={() => {
            // noop
        }}
    >
        {/* ... */}
    </FinalForm>
`}
/>

### Differences between Comet Admin `FinalForm` and React Final Form's `Form`

RFF's `Form` is a pure wrapper component.
It creates and maintains a [form instance](https://final-form.org/docs/final-form/api#createform) that handles the form state.
This form instance is provided to child components via React Context.
It doesn't render any HTML.

Comet Admin `FinalForm` renders some HTML: a `<form>` wrapper and a div containing submit errors.
Additionally, it uses the React Contexts of other Comet Admin components to interact with them.
You can find more information about these interactions in the following sections.

The following example shows the definition of a simple form with RFF `Form` and Comet Admin `FinalForm`.

Plain RFF `Form`:

<Source
    language="tsx"
    code={dedent`
        <RFFForm
            onSubmit={(values) => {
                // ...
            }}
        >
            {(props) => (
                <form onSubmit={props.handleSubmit}>
                    <RFFField name="name" component="input" />
                    <button type="submit">Save</button>
                </form>
            )}
        </RFFForm>
  `}
/>

Comet Admin `FinalForm`:

<Source
    language="tsx"
    code={dedent`
        <FinalForm
            mode="add"
            onSubmit={(values) => {
                // ...
            }}
        >
            <Field label="Name" name="name" component={FinalFormInput} />
            <SaveButton type="submit" />
        </FinalForm>
  `}
/>
